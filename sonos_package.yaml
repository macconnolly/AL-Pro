###############################################################################
#  Sonos & Apple TV Multimedia Control Package                                #
#  Uses Script + Helpers for Sonos Alarm Info Calculation (User Version)      #
#  Includes Apple TV Idle Timeout                                             #
#  Uses Event Trigger for Sonos Alarm Updates                                 #
#  FIXED: Corrected variable definitions in debug/disable scripts             #
#  FIXED: Corrected Apple TV automation conditions                            #
#  FIXED: Removed confusing debug message line                                #
#  UPDATED: Default display entity ID                                         #
#  FIXED: Corrected 'today' undefined error in debug_sonos_alarms script      #
#  FIXED: Corrected final summary logic in debug_sonos_alarms script          #
#  FIXED: Corrected variable definition in evening_alarm_check_notification   #
#  SIMPLIFIED: evening_alarm_check_notification to check only soonest alarm   #
#  FIXED: Corrected attribute access in disable_tomorrows_sonos_alarms        #
###############################################################################

# The soonest-alarm helpers and their update script are now deprecated and replaced by the centralized sensor.
# All scripts now use 'sensor.sonos_alarms_for_tomorrow' for tomorrow's alarm logic.
# See the 'Sonos Alarms for Tomorrow' sensor for all relevant attributes and debug info.
# All alarm-identification logic is now centralized for maintainability and robustness.

############################
#  USER HELPERS            #
############################
input_boolean:
  # Sonos Helpers
  sonos_auto_group_enabled:
    name: Sonos Auto-Group Enabled
    icon: mdi:account-music
    initial: true

  sonos_alarm_notifications:
    name: Sonos Alarm Notifications Enabled
    icon: mdi:bell-ring-outline
    initial: on

  # Apple TV Helpers
  apple_tv_no_auto_off:
    name: Apple TV - Prevent Auto Off
    icon: mdi:television-pause
    initial: false

input_number:
  sonos_default_volume:
    name: Sonos Default Volume
    icon: mdi:volume-medium
    min: 0
    max: 1
    step: 0.05
    unit_of_measurement: "vol"
    mode: slider

input_text:
  # Shared helper for push notifications
  notify_target_device_id:
    name: Device-ID for Multimedia Pushes
    icon: mdi:cellphone
    mode: text # Ensure mode is text
    initial: a09d6105c2e90cc42e7264679d34b17a  #  <-- REPLACE with your phone's ID

  # DEPRECATED: soonest_sonos_alarm_entity_id helper is no longer needed.
  # soonest_sonos_alarm_entity_id:
  #   name: Soonest Sonos Alarm Entity ID
  #   icon: mdi:identifier
  #   initial: "None"

  # NEW: Apple TV entity ID helpers (configurable)
  apple_tv_entity_id:
    name: Apple TV Entity ID
    icon: mdi:apple
    initial: media_player.living_room_apple_tv
    mode: text

  apple_tv_display_entity_id:
    name: Apple TV Display Entity ID
    icon: mdi:television
    initial: media_player.living_room_samsung_q60 # UPDATED Default
    mode: text

  # NEW: Helper to store disabled Sonos alarms for re-enabling later
  sonos_alarms_disabled_for_tomorrow:
    name: Sonos Alarms Disabled for Tomorrow
    icon: mdi:alarm-off
    mode: text
    initial: ""




############################
#  SPEAKER GROUP           #
############################
group:
  sonos_all:
    name: All Sonos Speakers
    entities:                       #  <-- ADJUST to match your setup
      - media_player.kitchen
      - media_player.living_room
      - media_player.office
      - media_player.bed
      - media_player.bath



############################
#  TEMPLATE SENSORS        #
############################
template:
  sensor:
    - name: "Sonos Alarms for Tomorrow"
      unique_id: sonos_alarms_for_tomorrow
      icon: mdi:alarm-multiple
      state: >
        {{ state_attr('sensor.sonos_alarms_for_tomorrow', 'alarm_count') | default(0) }} alarm(s) scheduled for tomorrow.
      attributes:
        all_alarms_data: >
          {%- set tomorrow_date_obj = (now() + timedelta(days=1)).date() -%}
          {%- set ns = namespace(collected_alarms_for_tomorrow = []) -%}
          {%- set now_dt = now() -%}

          {# Iterate through Sonos alarm switches that are 'on' and have a 'time' attribute (lowercase) #}
          {%- for alarm_entity in states.switch
              | selectattr('entity_id','search','sonos_alarm_')
              | selectattr('state','eq','on') -%}
            {%- set time_str = alarm_entity.attributes.get('time') -%}
            {%- if not time_str %}{% continue %}{% endif -%}

            {%- set recurrence = (alarm_entity.attributes.get('recurrence') | default('DAILY')) | upper -%}
            {%- set base_time = today_at(time_str) -%}

            {# Check recurrence for up to 7 days ahead #}
            {%- for i in range(7) -%}
              {%- set check_datetime = base_time + timedelta(days=i) -%}
              {%- set weekday_sonos = check_datetime.isoweekday() % 7 -%} {# 0=Sun, 1=Mon, ..., 6=Sat #}
              {%- set day_matches_recurrence = false -%}

              {%- if recurrence == 'DAILY' %}{% set day_matches_recurrence = true %}{% endif -%}
              {%- if recurrence == 'WEEKDAYS' and 1 <= weekday_sonos <= 5 %}{% set day_matches_recurrence = true %}{% endif -%}
              {%- if recurrence == 'WEEKENDS' and (weekday_sonos == 0 or weekday_sonos == 6) %}{% set day_matches_recurrence = true %}{% endif -%}
              {%- if recurrence.startswith('ON_') -%}
                {%- set days_in_recurrence = recurrence.split('_',1)[1] -%}
                {%- if weekday_sonos|string in days_in_recurrence %}{% set day_matches_recurrence = true %}{% endif -%}
              {%- endif -%}

              {# If the alarm is scheduled for this checked day and is in the future #}
              {%- if day_matches_recurrence and check_datetime > now_dt -%}
                {# If this checked day is tomorrow #}
                {%- if check_datetime.date() == tomorrow_date_obj -%}
                  {%- set existing_entity_ids = ns.collected_alarms_for_tomorrow | map(attribute='entity_id') | list -%}
                  {%- if alarm_entity.entity_id not in existing_entity_ids -%}
                    {%- set alarm_item = {
                        'entity_id': alarm_entity.entity_id,
                        'time': time_str,
                        'friendly_name': alarm_entity.attributes.get('friendly_name') | default(alarm_entity.name),
                        'timestamp': check_datetime.timestamp(),
                        'room': area_name(alarm_entity.entity_id) | default('Unknown')
                    } -%}
                    {%- set ns.collected_alarms_for_tomorrow = ns.collected_alarms_for_tomorrow + [alarm_item] -%}
                  {%- endif -%}
                  {# Only break if we found a match for tomorrow #}
                  {%- break -%}
                {%- endif -%}
              {%- endif -%}
            {%- endfor -%} {# End of i in range(7) loop #}
          {%- endfor -%} {# End of alarm_entity loop #}

          {# Post-loop processing #}
          {%- set sorted_alarms = ns.collected_alarms_for_tomorrow | sort(attribute='timestamp') -%}

          {%- set earliest_alarm_item = (sorted_alarms | first) if sorted_alarms else none -%}
          {%- set earliest_ts = earliest_alarm_item.timestamp if earliest_alarm_item else none -%}
          {%- set earliest_dt_local = as_datetime(earliest_ts) if earliest_ts is not none else none %}

          {%- set output_data = {
              'alarm_count': sorted_alarms | length,
              'alarm_entities': sorted_alarms | map(attribute='entity_id') | list,
              'friendly_names': sorted_alarms | map(attribute='friendly_name') | list,
              'rooms': sorted_alarms | map(attribute='room') | unique | list,
              'earliest_alarm_timestamp_tomorrow': earliest_ts,
              'earliest_alarm_time_tomorrow': as_local(as_datetime(earliest_ts)).strftime('%H:%M:%S') if earliest_ts is not none else 'None',
              'raw_alarm_list_sorted': sorted_alarms,
              'debug_tomorrow_date_obj': tomorrow_date_obj.isoformat(),
              'debug_processing_time_utc': now().isoformat()
          } -%}
          {{- output_data -}}
        alarm_count: >
          {% set data = state_attr('sensor.sonos_alarms_for_tomorrow', 'all_alarms_data') %}
          {{ data.get('alarm_count', 0) if data is mapping else 0 }}
        alarm_entities: >
          {% set data = state_attr('sensor.sonos_alarms_for_tomorrow', 'all_alarms_data') %}
          {{ data.get('alarm_entities', []) if data is mapping else [] }}
        friendly_names: >
          {% set data = state_attr('sensor.sonos_alarms_for_tomorrow', 'all_alarms_data') %}
          {{ data.get('friendly_names', []) if data is mapping else [] }}
        earliest_alarm_time_tomorrow: >
          {% set data = state_attr('sensor.sonos_alarms_for_tomorrow', 'all_alarms_data') %}
          {{ data.get('earliest_alarm_time_tomorrow', 'None') if data is mapping else 'None' }}
        earliest_alarm_timestamp_tomorrow: >
          {% set data = state_attr('sensor.sonos_alarms_for_tomorrow', 'all_alarms_data') %}
          {{ data.get('earliest_alarm_timestamp_tomorrow', none) if data is mapping else none }}
        debug_info: >
          {% set all_data_dict = state_attr('sensor.sonos_alarms_for_tomorrow', 'all_alarms_data') %}
          {% set output_dict = {} %}
          {% if all_data_dict is mapping %}
            {% set output_dict = {
                'retrieved_alarm_count': all_data_dict.get('alarm_count', 'Error: key missing'),
                'retrieved_earliest_time': all_data_dict.get('earliest_alarm_time_tomorrow', 'Error: key missing'),
                'retrieved_entities_sample': (all_data_dict.get('alarm_entities', []) | list | first) if (all_data_dict.get('alarm_entities', []) | list | length > 0) else 'No entities',
                'all_alarms_data_is_map': true,
                'all_alarms_data_keys': all_data_dict.keys() | list,
                'current_sensor_state': states('sensor.sonos_alarms_for_tomorrow')
               } %}
          {% else %}
            {% set output_dict = {
                'retrieved_alarm_count': 'Error: all_alarms_data not a map',
                'retrieved_earliest_time': 'Error',
                'retrieved_entities_sample': 'Error',
                'all_alarms_data_is_map': false,
                'current_sensor_state': states('sensor.sonos_alarms_for_tomorrow')
               } %}
          {% endif %}
          {{ output_dict | to_json }}
        rooms: >
          {% set data = state_attr('sensor.sonos_alarms_for_tomorrow', 'all_alarms_data') %}
          {{ data.get('rooms', []) if data is mapping else [] }}

    - name: "Sonos Upcoming Alarms"
      unique_id: sonos_upcoming_alarms
      icon: mdi:alarm-multiple
      state: >
        {{ state_attr('sensor.sonos_upcoming_alarms', 'alarm_count') | default(0) }} upcoming alarm(s).
      attributes:
        all_alarms_data: >
          {%- set today_date_obj = now().date() -%}
          {%- set tomorrow_date_obj = (now() + timedelta(days=1)).date() -%}
          {%- set ns = namespace(collected_alarms = []) -%}
          {%- set now_dt = now() -%}

          {# DEBUG: Collect all sonos_alarm_ entities and their attributes for troubleshooting #}
          {%- set debug_alarm_entities = states.switch
              | selectattr('entity_id','search','sonos_alarm_')
              | map(attribute='attributes')
              | list -%}

          {# Iterate through Sonos alarm switches that have a 'time' attribute and are enabled #}
          {%- for alarm_entity in states.switch
              | selectattr('entity_id','search','sonos_alarm_')
              | selectattr('state','eq','on') -%}
            {%- set time_str = alarm_entity.attributes.get('time') -%}
            {%- if not time_str %}{% continue %}{% endif -%}

            {%- set recurrence = (alarm_entity.attributes.get('recurrence') | default('DAILY')) | upper -%}
            {%- set base_time = today_at(time_str) -%}

            {# Check recurrence for today and tomorrow only #}
            {%- for i in range(2) -%}
              {%- set check_datetime = base_time + timedelta(days=i) -%}
              {%- set weekday_sonos = check_datetime.isoweekday() % 7 -%} {# 0=Sun, 1=Mon, ..., 6=Sat #}
              {%- set day_matches_recurrence = false -%}

              {%- if recurrence == 'DAILY' %}{% set day_matches_recurrence = true %}{% endif -%}
              {%- if recurrence == 'WEEKDAYS' and 1 <= weekday_sonos <= 5 %}{% set day_matches_recurrence = true %}{% endif -%}
              {%- if recurrence == 'WEEKENDS' and (weekday_sonos == 0 or weekday_sonos == 6) %}{% set day_matches_recurrence = true %}{% endif -%}
              {%- if recurrence.startswith('ON_') -%}
                {%- set days_in_recurrence = recurrence.split('_',1)[1] -%}
                {%- if weekday_sonos|string in days_in_recurrence %}{% set day_matches_recurrence = true %}{% endif -%}
              {%- endif -%}

              {# If the alarm is scheduled for this checked day and is in the future #}
              {%- if day_matches_recurrence and check_datetime > now_dt -%}
                {%- set alarm_item = {
                    'entity_id': alarm_entity.entity_id,
                    'time': time_str,
                    'friendly_name': alarm_entity.attributes.get('friendly_name') | default(alarm_entity.name),
                    'timestamp': check_datetime.timestamp(),
                    'date': check_datetime.date().isoformat(),
                    'recurrence': recurrence,
                    'room': area_name(alarm_entity.entity_id) | default('Unknown')
                } -%}
                {%- set ns.collected_alarms = ns.collected_alarms + [alarm_item] -%}
              {%- endif -%}
            {%- endfor -%}
          {%- endfor -%}

          {# Post-loop processing #}
          {%- set sorted_alarms = ns.collected_alarms | sort(attribute='timestamp') -%}
          {%- set earliest_alarm_item = (sorted_alarms | first) if sorted_alarms else none -%}
          {%- set earliest_ts = earliest_alarm_item.timestamp if earliest_alarm_item else none -%}
          {%- set earliest_dt_local = as_datetime(earliest_ts) if earliest_ts is not none else none %}

          {%- set output_data = {
              'alarm_count': sorted_alarms | length,
              'alarm_entities': sorted_alarms | map(attribute='entity_id') | list,
              'friendly_names': sorted_alarms | map(attribute='friendly_name') | list,
              'rooms': sorted_alarms | map(attribute='room') | unique | list,
              'earliest_alarm_timestamp': earliest_ts,
              'earliest_alarm_time': earliest_dt_local.strftime('%Y-%m-%d %H:%M:%S') if earliest_dt_local else 'None',
              'raw_alarm_list_sorted': sorted_alarms,
              'debug_today_date_obj': today_date_obj.isoformat(),
              'debug_tomorrow_date_obj': tomorrow_date_obj.isoformat(),
              'debug_processing_time_utc': now().isoformat(),
              'debug_all_alarm_entities': debug_alarm_entities
          } -%}
          {{- output_data -}}
        alarm_count: >
          {% set data = state_attr('sensor.sonos_upcoming_alarms', 'all_alarms_data') %}
          {{ data.get('alarm_count', 0) if data is mapping else 0 }}
        alarm_entities: >
          {% set data = state_attr('sensor.sonos_upcoming_alarms', 'all_alarms_data') %}
          {{ data.get('alarm_entities', []) if data is mapping else [] }}
        friendly_names: >
          {% set data = state_attr('sensor.sonos_upcoming_alarms', 'all_alarms_data') %}
          {{ data.get('friendly_names', []) if data is mapping else [] }}
        earliest_alarm_time: >
          {% set data = state_attr('sensor.sonos_upcoming_alarms', 'all_alarms_data') %}
          {{ data.get('earliest_alarm_time', 'None') if data is mapping else 'None' }}
        earliest_alarm_timestamp: >
          {% set data = state_attr('sensor.sonos_upcoming_alarms', 'all_alarms_data') %}
          {{ data.get('earliest_alarm_timestamp', none) if data is mapping else none }}
        rooms: >
          {% set data = state_attr('sensor.sonos_upcoming_alarms', 'all_alarms_data') %}
          {{ data.get('rooms', []) if data is mapping else [] }}
        debug_info: >
          {% set all_data_dict = state_attr('sensor.sonos_upcoming_alarms', 'all_alarms_data') %}
          {% set output_dict = {} %}
          {% if all_data_dict is mapping %}
            {% set output_dict = {
                'retrieved_alarm_count': all_data_dict.get('alarm_count', 'Error: key missing'),
                'retrieved_earliest_time': all_data_dict.get('earliest_alarm_time', 'Error: key missing'),
                'retrieved_entities_sample': (all_data_dict.get('alarm_entities', []) | list | first) if (all_data_dict.get('alarm_entities', []) | list | length > 0) else 'No entities',
                'all_alarms_data_is_map': true,
                'all_alarms_data_keys': all_data_dict.keys() | list,
                'current_sensor_state': states('sensor.sonos_upcoming_alarms')
               } %}
          {% else %}
            {% set output_dict = {
                'retrieved_alarm_count': 'Error: all_alarms_data not a map',
                'retrieved_earliest_time': 'Error',
                'retrieved_entities_sample': 'Error',
                'all_alarms_data_is_map': false,
                'current_sensor_state': states('sensor.sonos_upcoming_alarms')
               } %}
          {% endif %}
          {{ output_dict | to_json }}

    - name: "Soonest Sonos Alarm Info"
      unique_id: soonest_sonos_alarm_info
      icon: mdi:alarm
      state: >
        {%- set all_data = state_attr('sensor.sonos_upcoming_alarms', 'all_alarms_data') | default({}, true) -%}
        {%- set alarms = all_data.get('raw_alarm_list_sorted', []) if all_data is mapping else [] -%}
        {%- set soonest = alarms[0] if alarms|length > 0 else none -%}
        {{ soonest.time if soonest is mapping and 'time' in soonest else 'unknown' }}
      attributes:
        entity_id: >
          {%- set all_data = state_attr('sensor.sonos_upcoming_alarms', 'all_alarms_data') | default({}, true) -%}
          {%- set alarms = all_data.get('raw_alarm_list_sorted', []) if all_data is mapping else [] -%}
          {%- set soonest = alarms[0] if alarms|length > 0 else none -%}
          {{ soonest.entity_id if soonest is mapping and 'entity_id' in soonest else null }}
        friendly_name: >
          {%- set all_data = state_attr('sensor.sonos_upcoming_alarms', 'all_alarms_data') | default({}, true) -%}
          {%- set alarms = all_data.get('raw_alarm_list_sorted', []) if all_data is mapping else [] -%}
          {%- set soonest = alarms[0] if alarms|length > 0 else none -%}
          {{ soonest.friendly_name if soonest is mapping and 'friendly_name' in soonest else 'Soonest Sonos Alarm Info' }}
        room: >
          {%- set all_data = state_attr('sensor.sonos_upcoming_alarms', 'all_alarms_data') | default({}, true) -%}
          {%- set alarms = all_data.get('raw_alarm_list_sorted', []) if all_data is mapping else [] -%}
          {%- set soonest = alarms[0] if alarms|length > 0 else none -%}
          {{ soonest.room if soonest is mapping and 'room' in soonest else 'Unknown' }}
        timestamp: >
          {%- set all_data = state_attr('sensor.sonos_upcoming_alarms', 'all_alarms_data') | default({}, true) -%}
          {%- set alarms = all_data.get('raw_alarm_list_sorted', []) if all_data is mapping else [] -%}
          {%- set soonest = alarms[0] if alarms|length > 0 else none -%}
          {{ soonest.timestamp if soonest is mapping and 'timestamp' in soonest else null }}
        debug_info: >
          {%- set all_data = state_attr('sensor.sonos_upcoming_alarms', 'all_alarms_data') | default({}, true) -%}
          {%- set alarms = all_data.get('raw_alarm_list_sorted', []) if all_data is mapping else [] -%}
          {%- set soonest = alarms[0] if alarms|length > 0 else none -%}
          {{ soonest | to_json if soonest is mapping else '{}' }}

############################
#  SCRIPTS                 #
############################

script:
  confirmable_notification:
    alias: Generic Confirmable Notification
    mode: parallel # Allows multiple notifications to be handled concurrently
    icon: mdi:message-alert-outline
    fields:
      notify_device:
        description: "The target notification device ID. Defaults to input_text.notify_target_device_id if not provided or invalid."
        example: "mobile_app_your_device_id"
      title:
        description: "The title of the notification."
        example: "Confirm Action"
      message:
        description: "The main message body of the notification."
        example: "Do you want to proceed?"
      confirm_text:
        description: "Text for the confirmation button."
        example: "Yes, Proceed"
      confirm_actions:
        description: "A list of actions (service calls) to perform on confirmation."
        example: |
          - service: light.turn_on
            target:
              entity_id: light.living_room
      dismiss_text:
        description: "Text for the dismissal button."
        example: "No, Cancel"
      dismiss_actions:
        description: "A list of actions (service calls) to perform on dismissal (optional)."
        example: |
          - service: script.log_dismissal
      timeout_actions:
        description: "A list of actions (service calls) to perform on timeout (optional)."
        example: |
          - service: system_log.write
            data:
              message: "Notification timed out by script."
      timeout_seconds:
        description: "Timeout in seconds to wait for a response."
        example: 3600
        default: 3600 # Default to 1 hour
      notification_tag:
        description: "Optional tag for the notification (e.g., for replacing or clearing)."
        example: "confirm_power_off"
    sequence:
      - variables:
          action_confirm_event: "{{ 'CONFIRM_EVENT_' ~ context.id }}"
          action_dismiss_event: "{{ 'DISMISS_EVENT_' ~ context.id }}"
          effective_notify_device: >
            {% if notify_device is defined and notify_device not in ['', none, 'unavailable', 'unknown'] %}
              {{ notify_device }}
            {% else %}
              {{ states('input_text.notify_target_device_id') }}
            {% endif %}
          effective_tag: >
            {% if notification_tag is defined and notification_tag | string | length > 0 %}
              {{ notification_tag }}
            {% else %}
              {{ 'confirmable_notification_' ~ context.id.split('.')[0] }}
            {% endif %}

      - condition: template
        value_template: "{{ effective_notify_device not in ['', none, 'unavailable', 'unknown'] }}"
        alias: "Check if target device ID is valid"

      - service: notify.notify
        data:
          title: "{{ title }}"
          message: "{{ message }}"
          data:
            tag: "{{ effective_tag }}"
            actions:
              - action: "{{ action_confirm_event }}"
                title: "{{ confirm_text }}"
              - action: "{{ action_dismiss_event }}"
                title: "{{ dismiss_text }}"

      - wait_for_trigger:
          - platform: event
            event_type: mobile_app_notification_action
            event_data:
              action: "{{ action_confirm_event }}"
          - platform: event
            event_type: mobile_app_notification_action
            event_data:
              action: "{{ action_dismiss_event }}"
        timeout:
          seconds: "{{ timeout_seconds }}"
        continue_on_timeout: true

      - choose:
          - conditions: "{{ wait.trigger and wait.trigger.event.data.action == action_confirm_event }}"
            alias: "User confirmed"
            sequence:
              - repeat:
                  for_each: "{{ confirm_actions | default([]) }}"
                  sequence:
                    - service: "{{ repeat.item.service }}"
                      data: "{{ repeat.item.data | default({}) }}"
                      target: "{{ repeat.item.target | default({}) }}"
              - service: notify.notify
                data:
                  message: "Confirmed: {{ title }}."
                  data:
                    tag: "{{ effective_tag }}_receipt"

          - conditions: "{{ wait.trigger and wait.trigger.event.data.action == action_dismiss_event }}"
            alias: "User dismissed"
            sequence:
              - repeat:
                  for_each: "{{ dismiss_actions | default([]) }}"
                  sequence:
                    - service: "{{ repeat.item.service }}"
                      data: "{{ repeat.item.data | default({}) }}"
                      target: "{{ repeat.item.target | default({}) }}"
              - service: notify.notify
                data:
                  message: "Dismissed: {{ title }}."
                  data:
                    tag: "{{ effective_tag }}_receipt"
        default: # Timeout
          - service: system_log.write
            data:
              message: "Confirmable notification '{{ title }}' timed out. Tag: {{ effective_tag }}"
              level: warning
          - repeat:
              for_each: "{{ timeout_actions | default([]) }}"
              sequence:
                - service: "{{ repeat.item.service }}"
                  data: "{{ repeat.item.data | default({}) }}"
                  target: "{{ repeat.item.target | default({}) }}"

  # --- Debug Sonos Alarms (Removed: now fully centralized in sensor) ---
  # debug_sonos_alarms script has been removed; use the centralized sensor for all alarm debug info.

  # --- Calculate Soonest Alarm and Update Helpers ---
  # DEPRECATED: update_soonest_sonos_alarm_info script is no longer needed.
  # update_soonest_sonos_alarm_info:
  #   alias: Update Soonest Sonos Alarm Info Helpers
  #   icon: mdi:alarm-sync
  #   mode: single
  #   sequence:
  #     - variables:
  #         debug_lines: "Debug output temporarily disabled for update_soonest_sonos_alarm_info."
  #         soonest_entity_id: "" # Placeholder
  #         next_alarm_date: "{{ now().strftime('%Y-%m-%d') }}" # Placeholder
  #         next_alarm_time: "00:00:00" # Placeholder
  #     - service: persistent_notification.create
  #       data:
  #         title: Sonos Alarm Debug (Update Script - TEMPORARILY SIMPLIFIED)
  #         message: "{{ debug_lines }}" 
  #         notification_id: sonos_alarm_update_debug_simplified
  #     - choose:
  #         - conditions:
  #             - condition: template # This will likely be false with placeholder
  #               value_template: "{{ soonest_entity_id | length > 0 }}" 
  #           sequence:
  #             - service: input_datetime.set_datetime
  #               target:
  #                 entity_id: input_datetime.soonest_sonos_alarm_timestamp
  #               data:
  #                 date: "{{ next_alarm_date }}" 
  #                 time: "{{ next_alarm_time }}" 
  #             - service: input_text.set_value
  #               target:
  #                 entity_id: input_text.soonest_sonos_alarm_entity_id
  #               data:
  #                 value: "{{ soonest_entity_id }}"
  #       default: # This will likely always run with placeholders
  #         - service: input_text.set_value
  #           target:
  #             entity_id: input_text.soonest_sonos_alarm_entity_id
  #           data:
  #             value: "None (update_soonest_sonos_alarm_info is simplified)"
  #         - service: input_datetime.set_datetime
  #           target:
  #             entity_id: input_datetime.soonest_sonos_alarm_timestamp
  #           data:
  #             date: "{{ now().strftime('%Y-%m-%d') }}"
  #             time: "00:00:01" 

  # --- Group all speakers and set baseline volume --------------------------
  # Using version from user-provided working script
  sonos_group_all_speakers:
    alias: Sonos Group All Speakers
    mode: single
    icon: mdi:speaker-multiple
    sequence:
      - condition: state
        entity_id: input_boolean.sonos_auto_group_enabled
        state: "on"
      - variables:
          master: >
            {{ expand('group.sonos_all') | selectattr('state','ne','unavailable') | map(attribute='entity_id') | first | default(none) }}
      - choose:
          - conditions: "{{ master != none }}"
            sequence:
              - service: media_player.join
                target: { entity_id: "{{ master }}" }
                data:
                  group_members: >
                    {{ expand('group.sonos_all') | selectattr('state','ne','unavailable') | map(attribute='entity_id') | list }}
              - service: media_player.volume_set
                target:
                  entity_id: >
                    {{ expand('group.sonos_all') | selectattr('state','ne','unavailable') | map(attribute='entity_id') | list }}
                data:
                  volume_level: "{{ states('input_number.sonos_default_volume') | float(0.2) }}"
        default:
          - service: system_log.write
            data:
              message: "Sonos Group All: Could not find an available master speaker in group.sonos_all."
              level: warning

  # --- Disable only the alarms that ring tomorrow --------------------------
  # LOGIC MATCHES EVENING ALARM CHECK NOTIFICATION EXACTLY
  disable_tomorrows_sonos_alarms:
    alias: Disable Tomorrow's Sonos Alarms
    mode: single
    icon: mdi:alarm-off
    sequence:
      - variables:
          alarms_to_disable: >
            {{ state_attr('sensor.sonos_upcoming_alarms', 'alarm_entities') | default([]) }}
          # Build a comma-separated string of entity_ids up to 255 chars
          max_chars: 255
          entity_ids_str: >
            {%- set ns = namespace(s='') -%}
            {%- for eid in alarms_to_disable -%}
              {%- set next = (ns.s ~ (',' if ns.s else '') ~ eid) -%}
              {%- if next | length <= max_chars -%}
                {%- set ns.s = next -%}
              {%- else -%}
                {%- break -%}
              {%- endif -%}
            {%- endfor -%}
            {{ ns.s }}
          skipped_alarms: >
            {%- set ns = namespace(s='') -%}
            {%- set used = entity_ids_str.split(',') if entity_ids_str else [] -%}
            {%- for eid in alarms_to_disable -%}
              {%- if eid not in used -%}
                {%- set ns.s = ns.s ~ (',' if ns.s else '') ~ eid -%}
              {%- endif -%}
            {%- endfor -%}
            {{ ns.s }}
      - service: input_text.set_value
        target:
          entity_id: input_text.sonos_alarms_disabled_for_tomorrow
        data:
          value: "{{ entity_ids_str }}"
      - service: system_log.write
        data:
          message: |
            Sonos Alarm Disable Debug: Alarms to disable (from centralized sensor): {{ alarms_to_disable }}. Stored: {{ entity_ids_str }}. Skipped (due to 255-char limit): {{ skipped_alarms }}
          level: info
      - choose:
          - conditions: "{{ entity_ids_str | count > 0 }}"
            sequence:
              - service: switch.turn_off
                target:
                  entity_id: "{{ entity_ids_str.split(',') if entity_ids_str else [] }}"
              - service: system_log.write
                data:
                  message: "Disabled tomorrow's Sonos alarms: {{ entity_ids_str }}"
                  level: info
        default:
          - service: system_log.write
            data:
              message: "No active Sonos alarms found scheduled for tomorrow to disable."
              level: info

  # --- Nightly confirmable notification ---
  # UPDATED: Removed target from notify.notify calls. Uses simplified update script.
  evening_alarm_check_notification:
    alias: Evening Alarm Check Notification
    mode: single
    icon: mdi:bell-check-outline
    sequence:
      # Step 1: (No longer call update script, logic is centralized)
      # Step 2: Condition for notifications enabled
      - condition: state 
        entity_id: input_boolean.sonos_alarm_notifications
        state: "on"
      # Step 3: Define variables using the centralized sensor
      - variables:
          dev_id_check: "{{ states('input_text.notify_target_device_id') }}"
          alarms_for_tomorrow: >
            {{ state_attr('sensor.sonos_upcoming_alarms', 'alarm_entities') | default([]) }}
          count: "{{ state_attr('sensor.sonos_upcoming_alarms', 'alarm_count') | int(0) }}"
          earliest_time_str: "{{ state_attr('sensor.sonos_upcoming_alarms', 'earliest_alarm_time') | default('unknown') }}"
          notification_title: "Sonos Alarm Check (Tomorrow)"
          notification_message: >
            {{ count }} alarm{{ 's' if count != 1 else '' }} will ring tomorrow (earliest at {{ earliest_time_str }}). Disable them?
          action_confirm: "{{ 'SONOS_CONFIRM_' ~ context.id }}"
          action_dismiss: "{{ 'SONOS_DISMISS_' ~ context.id }}"
          confirm_button_text: "Disable"
          dismiss_button_text: "Keep Enabled"
      # Step 4: Check if there are alarms for tomorrow and if ANY device ID is set
      - condition: template
        value_template: >
          {{ count > 0 }}
      - condition: template
        value_template: "{{ dev_id_check != '' and dev_id_check != none and dev_id_check != 'unavailable' and dev_id_check != 'unknown' }}"
      # Step 5: Send the actionable notification
      - service: notify.notify
        data:
          title: "{{ notification_title }}"
          message: "{{ notification_message }}"
          data:
            actions:
              - action: "{{ action_confirm }}"
                title: "{{ confirm_button_text }}"
              - action: "{{ action_dismiss }}"
                title: "{{ dismiss_button_text }}"
      # Step 6: Wait for the user to tap an action
      - wait_for_trigger:
          - platform: event
            event_type: mobile_app_notification_action
            event_data:
              action: "{{ action_confirm }}"
          - platform: event
            event_type: mobile_app_notification_action
            event_data:
              action: "{{ action_dismiss }}"
        timeout: 
          hours: 1
        continue_on_timeout: false 
      # Step 7: Perform action based on the trigger
      - choose:
          - conditions: "{{ wait.trigger and wait.trigger.event.data.action == action_confirm }}"
            sequence:
              - service: script.disable_tomorrows_sonos_alarms
              - service: notify.notify 
                data:
                  message: "OK, tomorrow's Sonos alarms have been disabled."
          - conditions: "{{ wait.trigger and wait.trigger.event.data.action == action_dismiss }}"
            sequence:
              - service: notify.notify 
                data:
                  message: "OK, tomorrow's Sonos alarms will remain enabled."
        default: 
          - service: system_log.write
            data:
              message: "Sonos alarm notification confirmation timed out."
              level: warning
      # Step 8: Log if no alarms were found initially
      - condition: template 
        value_template: >
          {{ count == 0 }}
      - service: system_log.write
        data:
          message: "Evening Alarm Check: No Sonos alarms found scheduled for tomorrow (count was {{ count }})."
          level: info

  # --- Apple TV Auto Off Notification Script (with configurable entity IDs) ---
  apple_tv_auto_off_notification:
    alias: Apple TV Auto Off Notification
    mode: single
    icon: mdi:television-off
    fields:
      apple_tv_entity_id: # Field to accept from automation
        description: "The entity ID of the Apple TV that triggered the inactivity."
        example: "media_player.living_room_apple_tv"
      display_entity_id: # Field to accept from automation
        description: "The entity ID of the display associated with the Apple TV."
        example: "media_player.living_room_samsung_q60"
    sequence:
      - variables:
          dev_id: "{{ states('input_text.notify_target_device_id') }}"
          # Use entity_ids passed from automation via fields, otherwise fallback to global helpers
          # This makes the script more flexible if called directly, but automation should always provide them.
          effective_apple_tv_entity: "{{ apple_tv_entity_id if apple_tv_entity_id is defined else states('input_text.apple_tv_entity_id') }}"
          effective_display_entity: "{{ display_entity_id if display_entity_id is defined else states('input_text.apple_tv_display_entity_id') }}"
          apple_tv_friendly_name: "{{ state_attr(effective_apple_tv_entity, 'friendly_name') | default('The Apple TV') }}"

      - choose:
          # Condition 1: Check if a valid notification device ID is available
          - conditions:
              - condition: template
                value_template: "{{ dev_id != '' and dev_id != none and dev_id != 'unavailable' and dev_id != 'unknown' }}"
              # Condition 2: Check if the Apple TV entity to control is valid and not unavailable/unknown
              - condition: template
                value_template: "{{ effective_apple_tv_entity != '' and effective_apple_tv_entity != none and states(effective_apple_tv_entity) != 'unavailable' and states(effective_apple_tv_entity) != 'unknown' }}"
            sequence:
              - service: script.confirmable_notification
                data:
                  notify_device: "{{ dev_id }}" # Pass the target device ID
                  title: "{{ apple_tv_friendly_name }} Inactive"
                  message: "{{ apple_tv_friendly_name }} has been paused or idle for over 30 minutes. Would you like to turn it and the display off?"
                  confirm_text: "Yes, Turn Off"
                  confirm_actions: # Note: plural `confirm_actions`
                    - service: media_player.turn_off
                      target:
                        entity_id: "{{ effective_apple_tv_entity }}"
                    # Conditionally turn off display only if it's a valid entity and different from the Apple TV itself
                    - condition: template
                      value_template: >-
                        {{ effective_display_entity != '' and
                           effective_display_entity != none and
                           states(effective_display_entity) != 'unavailable' and
                           states(effective_display_entity) != 'unknown' and
                           effective_display_entity != effective_apple_tv_entity }}
                    - service: media_player.turn_off
                      target:
                        entity_id: "{{ effective_display_entity }}"
                  dismiss_text: "No, Keep On"
                  notification_tag: "apple_tv_auto_off_{{ effective_apple_tv_entity | replace('media_player.','') }}" # Unique tag per Apple TV
                  timeout_seconds: 1800 # 30 minutes timeout for this specific notification
                  # timeout_actions and dismiss_actions can be added here if needed
        default:
          - service: system_log.write
            data:
              message: "Apple TV Auto Off Notification: Not sent. Invalid notify_device ('{{ dev_id }}') or Apple TV entity ('{{ effective_apple_tv_entity }}')."
              level: warning

  soonest_sonos_alarm_info:
    alias: Soonest Sonos Alarm Info
    mode: single
    icon: mdi:alarm
    sequence:
      - variables:
          alarms: >
            {{ state_attr('sensor.sonos_upcoming_alarms', 'raw_alarm_list_sorted') | default([], true) }}
          soonest_alarm: >
            {{ alarms[0] if alarms|length > 0 else none }}
          soonest_entity_id: >
            {{ soonest_alarm.entity_id if soonest_alarm is mapping and 'entity_id' in soonest_alarm else 'None' }}
          soonest_time: >
            {{ soonest_alarm.time if soonest_alarm is mapping and 'time' in soonest_alarm else 'None' }}
          soonest_room: >
            {{ soonest_alarm.room if soonest_alarm is mapping and 'room' in soonest_alarm else 'Unknown' }}
          soonest_friendly_name: >
            {{ soonest_alarm.friendly_name if soonest_alarm is mapping and 'friendly_name' in soonest_alarm else soonest_entity_id }}
      - service: system_log.write
        data:
          message: |
            Soonest Sonos Alarm Info: Entity: {{ soonest_entity_id }}, Time: {{ soonest_time }}, Room: {{ soonest_room }}, Name: {{ soonest_friendly_name }}
          level: info
      # Optionally, set helpers or notify here if needed
      # - service: input_text.set_value
      #   target:
      #     entity_id: input_text.soonest_sonos_alarm_entity_id
      #   data:
      #     value: "{{ soonest_entity_id }}"
      # - service: persistent_notification.create
      #   data:
      #     title: "Soonest Sonos Alarm"
      #     message: "Entity: {{ soonest_entity_id }}, Time: {{ soonest_time }}, Room: {{ soonest_room }}"

############################
#  AUTOMATION              #
############################
automation:
  # Event-based trigger for Sonos alarm updates
  - id: sonos_alarm_trigger_update
    alias: Sonos Alarm State Change Trigger Update
    description: "Updates soonest alarm info helpers when any Sonos alarm switch changes."
    mode: queued
    max_exceeded: silent
    trigger:
      - platform: event
        event_type: state_changed
        event_data: {}
    condition:
      - condition: template
        value_template: >
          {{
            trigger.event.data.entity_id is defined
            and trigger.event.data.entity_id.startswith('switch.sonos_alarm_')
            and states(trigger.event.data.entity_id) is not none
          }}
    action:
      # Removed deprecated script.update_soonest_sonos_alarm_info call
      - service: system_log.write
        data:
          message: "Sonos alarm update triggered by: {{ trigger.event.data.entity_id }}"
          level: info

  # Sonos nightly prompt automation
  - id: sonos_nightly_prompt
    alias: Sonos Nightly Alarm Prompt 21:30
    description: "Triggers the evening alarm check notification script daily."
    mode: single
    trigger:
      - platform: time
        at: "21:30:00"
    condition: [] # Conditions can be added here if needed
    action:
      - service: script.evening_alarm_check_notification

  # Apple TV Auto-Off Automation with configurable entity ID
  - id: apple_tv_auto_off_after_inactivity
    alias: Apple TV Auto Off After Inactivity
    description: "Turns off Apple TV and display after 30 minutes of inactivity (paused/idle)."
    mode: single
    trigger:
      # Check every 5 minutes
      - platform: time_pattern
        minutes: "/5"
    condition:
      # AND conditions:
      - condition: state
        entity_id: input_boolean.apple_tv_no_auto_off
        state: 'off' # Only run if manual override is OFF
      # CORRECTED: Use template condition to check state of dynamic entity ID
      - condition: template
        value_template: >
          {% set entity_id = states('input_text.apple_tv_entity_id') %}
          {# Check if entity exists and is in the target state for 30 mins #}
          {% set entity_state = states(entity_id) %}
          {{ entity_state != 'unavailable' and entity_state != 'unknown' and (
               (is_state(entity_id, 'paused') and (now() - states[entity_id].last_changed).total_seconds() >= 1800)
               or
               (is_state(entity_id, 'idle') and (now() - states[entity_id].last_changed).total_seconds() >= 1800)
             )
          }}
    action:
      - service: script.apple_tv_auto_off_notification
        data:
          # Pass the entity ID to the script if needed
          apple_tv_entity_id: "{{ states('input_text.apple_tv_entity_id') }}"
          display_entity_id: "{{ states('input_text.apple_tv_display_entity_id') }}"
      # Log the action taken
      - service: system_log.write
        data:
          message: "Apple TV Auto Off: Apple TV has been inactive for 30+ minutes. Notification sent."
          level: warning

  - id: sonos_reenable_tomorrows_alarms
    alias: Sonos Re-Enable Tomorrow's Alarms at 21:00
    description: "Re-enables Sonos alarms that were disabled for tomorrow."
    mode: single
    trigger:
      - platform: time
        at: "21:00:00"
    condition: []
    action:
      - variables:
          alarms_to_reenable: >
            {{ states('input_text.sonos_alarms_disabled_for_tomorrow').split(',') if states('input_text.sonos_alarms_disabled_for_tomorrow') else [] }}
      - choose:
          - conditions: "{{ alarms_to_reenable | count > 0 }}"
            sequence:
              - service: switch.turn_on
                target:
                  entity_id: "{{ alarms_to_reenable }}"
              - service: input_text.set_value
                target:
                  entity_id: input_text.sonos_alarms_disabled_for_tomorrow
                data:
                  value: ""
              - service: system_log.write
                data:
                  message: "Re-enabled Sonos alarms: {{ alarms_to_reenable }}"
                  level: info
        default:
          - service: system_log.write
            data:
              message: "No Sonos alarms to re-enable at 21:00."
              level: info